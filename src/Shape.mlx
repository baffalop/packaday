open Fun

type piece = [
  | `Rect
  | `Thumb
  | `Corner
  | `Snake
  | `U
  | `L
  | `T
  | `Z
]

(** A single cell: O (empty/gap) or H (filled) *)
type segment =
  | O
  | H

type t = segment array array

let of_piece : piece -> t = function
  | `Rect -> [|
    [| H; H |];
    [| H; H |];
    [| H; H |];
  |]
  | `Thumb -> [|
    [| O; H |];
    [| H; H |];
    [| H; H |];
  |]
  | `Corner -> [|
    [| H; H; H |];
    [| O; O; H |];
    [| O; O; H |];
  |]
  | `L -> [|
    [| H; H |];
    [| H; O |];
    [| H; O |];
    [| H; O |];
  |]
  | `Snake -> [|
    [| H; O |];
    [| H; H |];
    [| O; H |];
    [| O; H |];
  |]
  | `T -> [|
    [| H; O |];
    [| H; H |];
    [| H; O |];
    [| H; O |];
  |]
  | `U -> [|
    [| H; H |];
    [| O; H |];
    [| H; H |];
  |]
  | `Z -> [|
    [| H; H; O |];
    [| O; H; O |];
    [| O; H; H |];
  |]

let string_of_piece = [%mel.raw {|tag => tag|}]

let[@react.component] make ~(t : t) ?(cellSize = 8) ?(className = "fill-rose-500") () =
  let rows = Array.length t in
  let cols = if rows > 0 then Array.length t.(0) else 0 in
  let height = rows * cellSize in
  let width = cols * cellSize in
  <svg
    width=(string_of_int width)
    height=(string_of_int height)
    viewBox=(Printf.sprintf "0 0 %d %d" width height)
    className="piece-shape"
  >
    (t |> Array.mapi (fun row_i row ->
      row |> Array.mapi (fun col_i seg ->
        match seg with
        | O -> React.null
        | H ->
          let x = col_i * cellSize in
          let y = row_i * cellSize in
          <rect
            key=(Printf.sprintf "%d-%d" row_i col_i)
            x=(string_of_int x)
            y=(string_of_int y)
            width=(string_of_int cellSize)
            height=(string_of_int cellSize)
            className
          />
      ) |> React.array
    ) |> React.array)
  </svg>

let rotate_cw t =
  let rows = Array.length t in
  let cols = if rows > 0 then Array.length t.(0) else 0 in
  Array.init_matrix cols rows @@ fun row col -> t.(rows - col - 1).(row)

let rotate_ccw t =
  let rows = Array.length t in
  let cols = if rows > 0 then Array.length t.(0) else 0 in
  Array.init_matrix cols rows @@ fun row col -> t.(col).(cols - row - 1)

let flip_horiz =
  Array.map @@ fun row ->
    let len = Array.length row in
    Array.init len @@ fun i -> row.(len - i - 1)

let flip_vert t =
  let len = Array.length t in
  Array.init len @@ fun i -> t.(len - i - 1)

let all_transformations (t : t) : t array =
  let r1 = rotate_cw t in
  let r2 = rotate_cw r1 in
  let r3 = rotate_cw r2 in
  let f = flip_horiz t in
  let fr1 = rotate_cw f in
  let fr2 = rotate_cw fr1 in
  let fr3 = rotate_cw fr2 in
  [|t; r1; r2; r3; f; fr1; fr2; fr3|]

let unique : 'a array -> 'a array =
  Array.fold_left (fun acc shape ->
    if Array.mem shape acc then acc
    else Array.append acc [|shape|]
  ) [||]

let variations : piece -> t array =
  unique << all_transformations << of_piece

module Test = struct
  open Fest

  let () = Test.run @@ fun () ->
    test "of_piece Thumb" @@ fun () ->
      expect |> deep_equal (of_piece `Thumb)
        [|
          [| O; H |];
          [| H; H |];
          [| H; H |];
        |];
    test "rotate_cw Thumb" @@ fun () ->
      expect |> deep_equal (rotate_cw @@ of_piece `Thumb)
        [|
          [| H; H; O |];
          [| H; H; H |];
        |];
    test "rotate_ccw Thumb" @@ fun () ->
      expect |> deep_equal (rotate_ccw @@ of_piece `Thumb)
        [|
          [| H; H; H |];
          [| O; H; H |];
        |];
    test "flip_horiz Thumb" @@ fun () ->
      expect |> deep_equal (flip_horiz @@ of_piece `Thumb)
        [|
          [| H; O |];
          [| H; H |];
          [| H; H |];
        |];
    test "flip_vert Thumb" @@ fun () ->
      expect |> deep_equal (flip_vert @@ of_piece `Thumb)
        [|
          [| H; H |];
          [| H; H |];
          [| O; H |];
        |];

    test "of_piece Snake" @@ fun () ->
      expect |> deep_equal (of_piece `Snake)
        [|
          [| H; O |];
          [| H; H |];
          [| O; H |];
          [| O; H |];
        |];
    test "rotate_cw Snake" @@ fun () ->
      expect |> deep_equal (rotate_cw @@ of_piece `Snake)
        [|
          [| O; O; H; H |];
          [| H; H; H; O |];
        |];
    test "rotate_ccw Snake" @@ fun () ->
      expect |> deep_equal (rotate_ccw @@ of_piece `Snake)
        [|
          [| O; H; H; H |];
          [| H; H; O; O |];
        |];
    test "flip_horiz Snake" @@ fun () ->
      expect |> deep_equal (flip_horiz @@ of_piece `Snake)
        [|
          [| O; H |];
          [| H; H |];
          [| H; O |];
          [| H; O |];
        |];
    test "flip_vert Snake" @@ fun () ->
      expect |> deep_equal (flip_vert @@ of_piece `Snake)
        [|
          [| O; H |];
          [| O; H |];
          [| H; H |];
          [| H; O |];
        |];

    test "variations for Rect" @@ fun () ->
      expect |> deep_equal (variations `Rect) [|
        [|
          [| H; H; |];
          [| H; H; |];
          [| H; H; |];
        |];
        [|
          [| H; H; H; |];
          [| H; H; H; |];
        |];
      |];

    test "variations for U" @@ fun () ->
      expect |> deep_equal (variations `U) [|
        [|
          [| H; H; |];
          [| O; H; |];
          [| H; H; |];
        |];
        [|
          [| H; O; H |];
          [| H; H; H |];
        |];
        [|
          [| H; H; |];
          [| H; O; |];
          [| H; H; |];
        |];
        [|
          [| H; H; H |];
          [| H; O; H |];
        |];
      |];

    test "8 variations for Thumb" @@ fun () ->
      expect |> equal (Array.length (variations `Thumb)) 8;
    test "8 variations for L" @@ fun () ->
      expect |> equal (Array.length (variations `L)) 8;
    test "8 variations for Snake" @@ fun () ->
      expect |> equal (Array.length (variations `Snake)) 8;
    test "4 variations for Z" @@ fun () ->
      expect |> equal (Array.length (variations `Z)) 4;
    test "8 variations for T" @@ fun () ->
      expect |> equal (Array.length (variations `T)) 8;
    test "4 variations for Corner" @@ fun () ->
      expect |> equal (Array.length (variations `Corner)) 4
end
